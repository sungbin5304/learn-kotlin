# 코틀린 기초

## 1. 변수 타입

String, Int, Float, Boolean, null



## 2. 스코프

#### \- 전역 스코프

최상위 코드 블록의 내부 접근 범위

-> 전역스코프에 전언된 존재는 모든 범위에서 접근 가능 (다른 코드블록을 다 포함하고 있음)



#### \- 지역스코프

전역스코프 안에 존재하는 또 다른 코드 블록의 내부 접근 범위

-> 지역스코프 안에 선언된 존재는 전역스코프에서 접근하지 못함 (코드블록이 다름)



## 3. 변수

#### \- 의미

데이터를 담고있는 객체



####  \- 구분

값을 수정할 수 있는 변수와 값을 수정할 수 없는 상수로 나뉜다.



#### \- 상수

`val`로 사용

π (3.141592……) 값 처럼 절대 변하면 안되는 데이터를 선언할 때 사용한다.

-> 값을 수정할 수 없음



#### \- 변수

`var`로 사용

변할 수 있는 값을 선언할 때 사용한다.

-> 값을 수정할 수 있음



#### \- 변수의 선언

[var/val] [변수명]: [변수타입] = [변수의 초깃값]

-> 선언 예시) `var a: Int = 1`



#### \- Smart Casting

위 선언 예시처럼 바로 변수를 선언함과 동시에 초깃값을 넣어줄때 코드 컴파일러가 알아서 변수의 타입을 추론한다.

따라서 `var a = 1` 처럼 타입 생략이 가능하다.



#### - 변수의 초기화

코틀린에서는 전역스코프에 선언된 변수는 선언과 동시에 초기화가 필수이다.

하지만 지역스코프는 변수 초기화를 변수 선언만 해두고 미룰 수 있다. (나중에 초기화 가능)



가끔씩 전역스코프에서 변수 초기화를 바로 할 수 없을 상황이 생기는데 이럴때 `lateinit`이라는 속성을 사용하여,

전역 스코프에서의 변수 초기화를 미룰 수 있다.

-> `lateinit var a: Int` 



하지만 변수 초기화를 미뤄줄 경우엔, `smart-casting`이 작동할 수 없으므로 직접 변수의 타입을 명시해 줘야 한다.



# if문

기초적인 사용 방법은 다음과 같다.

```kotlin
if (condition) {
  // todo
}
```

이때 `condition`의 값이 `true`인 경우에만 `//todo` 부분이 실행된다.



-> 간단한 사용 예시

```kotlin
val calc = 1 + 1
if (calc == 2) {
  print("1 + 1 의 값은 2가 맞습니다.")
}
```



위 if문의 `condition`으로 `calc == 2` 의 값이 `true` 이므로, `print(~~)` 함수가 실행된다.



이때 `== true`와 `== false` 같은 단순 `Boolean` 여부만 체크하는 식은 다음과 같이 생략이 가능하다.

```kotlin
if (A == true) -> if (A)
if (A == false) -> if (!A)
```
