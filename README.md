# 코틀린 기초

## 1. 변수 타입

`String`: 문지열

`Int`:  정수

`Float`: 실수

`Boolean`: `true`(참) / `false`(거짓)

`null`: 빈 값 (다 쓴 휴지곽 같은 느낌)



## 2. 스코프

#### - 의미

특정 요소가 접근 가능한 접위



#### \- 전역 스코프

최상위 코드 블록의 내부 접근 범위

-> 전역스코프에 전언된 존재는 모든 범위에서 접근 가능 (다른 코드블록을 다 포함하고 있음)



#### \- 지역스코프

전역스코프 안에 존재하는 또 다른 코드 블록의 내부 접근 범위

-> 지역스코프 안에 선언된 존재는 전역스코프에서 접근하지 못함 (코드블록이 다름)



## 3. 변수

#### \- 의미

데이터를 담고있는 객체



####  \- 구분

값을 수정할 수 있는 변수와 값을 수정할 수 없는 상수로 나뉜다.



#### \- 상수

`val`로 사용

π (3.141592……) 값 처럼 절대 변하면 안되는 데이터를 선언할 때 사용한다.

-> 값을 수정할 수 없음



#### \- 변수

`var`로 사용

변할 수 있는 값을 선언할 때 사용한다.

-> 값을 수정할 수 있음



#### \- 선언

[var/val] [변수명]: [변수타입] = [변수의 초깃값]

>  `var a: Int = 1`



#### \- Smart Casting

위 선언 예시처럼 바로 변수를 선언함과 동시에 초깃값을 넣어줄때 코드 컴파일러가 알아서 변수의 타입을 추론한다.

따라서 `var a = 1` 처럼 타입 생략이 가능하다.



#### - 초기화

코틀린에서는 전역스코프에 선언된 변수는 선언과 동시에 초기화가 필수이다.

하지만 지역스코프는 변수 초기화를 변수 선언만 해두고 미룰 수 있다. (나중에 초기화 가능)



#### - 늦은 초기화

가끔씩 전역스코프에서 변수 초기화를 바로 할 수 없을 상황이 생기는데 이럴때 `lateinit`이라는 속성을 사용하여,

전역 스코프에서의 변수 초기화를 미룰 수 있다.

> `lateinit var a: Int` 



하지만 변수 초기화를 미뤄줄 경우엔, `SmartCasting`이 작동할 수 없으므로 직접 변수의 타입을 명시해 줘야 한다.



#### - 사용 시점에 하는 초기화

코틀린은 변수를 선언함과 동시에 값이 바로 초기화된다. (값을 넣어준 경우에)

하지만 가끔식 변수가 최초 사용되는 시점에 값 초기화가 이루어져야 할 때가 있다.

이럴땐 `by lazy`라는 키워드를 통해 해결할 수 있다.



사용 방법은 다음과 같다.

val [변수명] by lazy { 초기화 값 }

> `val lazyInitVariable by lazy { 1 }` -> lazyInitVariable 변수가 사용되는 시점에 1이라는 값이 들어감



이때 `by lazy`는 해당 변수가 최초 사용될 때 딱 한 번만 초기화 하므로, 더 이상의 값 초기화(값 변경)이 불가능하다.

따라서 무조건 상수로 고정된다.



## 4. if문

#### - 의미

명령들을 특정 조건에만 실행되게 해 준다.



#### - 사용법

```kotlin
if (condition) {
  // todo
}
```

이때 `condition`의 값이 `true`인 경우에만 `//todo` 부분이 실행된다.



#### - 예시

```kotlin
val calc = 1 + 1
if (calc == 2) {
  print("1 + 1 의 값은 2가 맞습니다.")
}
```



위 if문의 `condition`으로 `calc == 2` 의 값이 `true` 이므로, `print(~~)` 함수가 실행된다.



이때 `== true`와 `== false` 같은 단순 `Boolean` 여부만 체크하는 식은 다음과 같이 생략이 가능하다.

```kotlin
if (A == true) -> if (A)
if (A == false) -> if (!A)
```



## 5. 함수

#### - 의미

명령어들의 집한체



#### - 선언법

```kotlin
fun [함수이름](함수인자): [반환타입] {
  // todo
}
```



#### - 인자

인자란 함수를 사용할 때 같이 제공해줄 데이터를 뜻한다.

인자 명시는 변수 사용 규칙과 동일하게 할 수 있다.

>  `[인자명]: [인자타입] = [기본값]`

이때 인자의 기본값을 작성해주게 되면, 해당 인자는 선택사항으로 되고

기본값을 작성해주지 않았다면, 해당 인자는 필수사항으로 된다.



#### - 반환

반환이란 함수를 사용한 부분에 특정 값을 넘겨주는것을 뜻 한다.

`return` 키워드를 사용하여 반환값을 줄 수 있다.

```kotlin
fun getA(): Int {
  return 1 // 1은 정수, 즉 Int 이므로 반환타입을 Int로 명시
}
```



이때 모든 함수의 기본 반환타입은 `Unit` 이며, 이건 아무것도 반환하지 않는 타입을 뜻한다.

> `Unit`은 기본 타입이라 함수 선언시 생략 가능 



#### - 간략화

`- 반환` 챕터의 예시처럼 함수가 특정 값을 리턴하는 명렁 하나로 구성돼 있을경우,

반환 값을 함수에 바로 대입하는 식으로 함수 선언을 간력화 해줄 수 있다.

또한 값을 바로 대입하므로, `Smart-Casting`이 적용돼 반환타입을 생략할 수 있다.

```kotlin
fun getA() = 1 // - 반환 챕터의 예시 함수와 같은 동작을 하는 함수
```



#### - 사용 예시

```kotlin
fun plus(one: Int, two: Int) = one + two // plus(1, 1) -> 2

fun divideWithOne(value: Int, one: Int = 1) = value / one // always `value`
```



## Null-Safety 속성

#### - Nul-Safety?

`null`인 요소에 특정 값을 가져오는 행동 같은 명령을 실행하면, 없는 값으로부터 요청했기에 오류가 발생한다.

이러한 상황을 효율적으로 제어할 수 있게 도와주는 속성이 `Null-Safety`인데 코틀린은 이 속성이 적용되었다.



#### - !!

`!!` 키워드는 값이 무조건 `null`이 아님을 약속한다.



사용법: [변수명]!!

> var a  = 1
>
> a!! // a는 null이 절대 아님을 보장

!!는 무조건 이게  `null`이 아님을 보장할 수 있는 순간 아니면 최대한 사용을 하지 않는게 좋다.

그래서 코틀린 개발자가 `!!`라는 못생긴 기호를 채택했다. 



#### - ?:

`?!` 키워드는 앞 조건이 `null`일 때 뒤 조건을 실행시키며, `엘비스 연산자`라고 불린다.

```kotlin
var a = null
var b = 1
var c = a ?: b // c에는 1이 들어감
```

`a ?: b` 에서 앞 조건인 `a`가 `null`이므로, 뒤 조건인 `b`의 값인 1이 `c` 변수에 들어간다.



#### - ?.

`?.` 키워드는 앞 조건이 `null`이 아닐때만 뒤 조건을 실행시키고, 만약 앞 조건이 `null`이라면 `null` 을 리턴한다.

```kotlin
var people = People()
var name = people?.name // people의 이름이 들어감
```

`people?.name`에서 앞 조건인 `people`이 `null`이 아닌 `People`이라는 값으로 초기화 됬으므로,

뒤 조건인 `name` 이 실행된다.



`?.` 키워드는 `엘비스 연산자`와 함께 쓰인다.

```kotlin
var people = null
var name = people?.name ?: "people 값이 없습니다" // `people 값이 없습니다`가 들어감
```

`people?.name ?: "people 값이 없습니다"`를 보면 `people`의 선언을 `null`로 해줬으므로,

앞 조건에 `null`이 들어와 뒤 조건인 `"people 값이 없습니다"`가 실행된다.

