# 1. 코틀린 기초

## 1. 변수 타입

`String`: 문지열

`Int`:  정수

`Float`: 실수

`Boolean`: `true`(참) / `false`(거짓)

`null`: 빈 값 (다 쓴 휴지곽 같은 느낌)

<img src="https://github.com/jisungbin/learn-kotlin-with-android/blob/master/images/null.jpg?raw=true" alt="null.jpg" style="zoom: 50%;" />



## 2. 스코프

#### - 의미

특정 요소가 접근 가능한 접위



#### \- 전역 스코프

최상위 코드 블록의 내부 접근 범위

-> 전역스코프에 전언된 존재는 모든 범위에서 접근 가능 (다른 코드블록을 다 포함하고 있음)



#### \- 지역스코프

전역스코프 안에 존재하는 또 다른 코드 블록의 내부 접근 범위

-> 지역스코프 안에 선언된 존재는 전역스코프에서 접근하지 못함 (코드블록이 다름)



## 3. 변수

#### \- 의미

데이터를 담고있는 객체



####  \- 구분

값을 수정할 수 있는 변수와 값을 수정할 수 없는 상수로 나뉜다.



#### \- 상수

`val`로 사용

π (3.141592……) 값 처럼 절대 변하면 안되는 데이터를 선언할 때 사용한다.

-> 값을 수정할 수 없음



#### \- 변수

`var`로 사용

변할 수 있는 값을 선언할 때 사용한다.

-> 값을 수정할 수 있음



#### \- 선언

[var/val] [변수명]: [변수타입] = [변수의 초깃값]

>  `var a: Int = 1`



#### \- Smart Casting

위 선언 예시처럼 바로 변수를 선언함과 동시에 초깃값을 넣어줄때 코드 컴파일러가 알아서 변수의 타입을 추론한다.

따라서 `var a = 1` 처럼 타입 생략이 가능하다.



#### - 초기화

코틀린에서는 전역스코프에 선언된 변수는 선언과 동시에 초기화가 필수이다.

하지만 지역스코프는 변수 초기화를 변수 선언만 해두고 미룰 수 있다. (나중에 초기화 가능)



#### - 늦은 초기화

가끔씩 전역스코프에서 변수 초기화를 바로 할 수 없을 상황이 생기는데 이럴때 `lateinit`이라는 속성을 사용하여,

전역 스코프에서의 변수 초기화를 미룰 수 있다.

> `lateinit var a: Int` 



하지만 변수 초기화를 미뤄줄 경우엔, `SmartCasting`이 작동할 수 없으므로 직접 변수의 타입을 명시해 줘야 한다.



#### - 사용 시점에 하는 초기화

코틀린은 변수를 선언함과 동시에 값이 바로 초기화된다. (값을 넣어준 경우에)

하지만 가끔식 변수가 최초 사용되는 시점에 값 초기화가 이루어져야 할 때가 있다.

이럴땐 `by lazy`라는 키워드를 통해 해결할 수 있다.



사용 방법은 다음과 같다.

val [변수명] by lazy { 초기화 값 }

> `val lazyInitVariable by lazy { 1 }` -> lazyInitVariable 변수가 사용되는 시점에 1이라는 값이 들어감



이때 `by lazy`는 해당 변수가 최초 사용될 때 딱 한 번만 초기화 하므로, 더 이상의 값 초기화(값 변경)이 불가능하다.

따라서 무조건 상수로 고정된다.



## 4. if문

#### - 의미

명령들을 특정 조건에만 실행되게 해 준다.



#### - 사용법

```kotlin
if (condition) {
  // todo
}
```

이때 `condition`의 값이 `true`인 경우에만 `//todo` 부분이 실행된다.



#### - 예시

```kotlin
val calc = 1 + 1
if (calc == 2) {
  print("1 + 1 의 값은 2가 맞습니다.")
}
```



위 if문의 `condition`으로 `calc == 2` 의 값이 `true` 이므로, `print(~~)` 함수가 실행된다.



이때 `== true`와 `== false` 같은 단순 `Boolean` 여부만 체크하는 식은 다음과 같이 생략이 가능하다.

```kotlin
if (A == true) -> if (A)
if (A == false) -> if (!A)
```



## 5. 함수

#### - 의미

명령어들의 집한체



#### - 선언법

```kotlin
fun [함수이름](함수인자): [반환타입] {
  // todo
}
```



#### - 인자

인자란 함수를 사용할 때 같이 제공해줄 데이터를 뜻한다.

인자 명시는 변수 사용 규칙과 동일하게 할 수 있다.

>  `[인자명]: [인자타입] = [기본값]`

이때 인자의 기본값을 작성해주게 되면, 해당 인자는 선택사항으로 되고

기본값을 작성해주지 않았다면, 해당 인자는 필수사항으로 된다.



#### - 반환

반환이란 함수를 사용한 부분에 특정 값을 넘겨주는것을 뜻 한다.

`return` 키워드를 사용하여 반환값을 줄 수 있다.

```kotlin
fun getA(): Int {
  return 1 // 1은 정수, 즉 Int 이므로 반환타입을 Int로 명시
}
```



이때 모든 함수의 기본 반환타입은 `Unit` 이며, 이건 아무것도 반환하지 않는 타입을 뜻한다.

> `Unit`은 기본 타입이라 함수 선언시 생략 가능 



#### - 간략화

`- 반환` 챕터의 예시처럼 함수가 특정 값을 리턴하는 명렁 하나로 구성돼 있을경우,

반환 값을 함수에 바로 대입하는 식으로 함수 선언을 간력화 해줄 수 있다.

또한 값을 바로 대입하므로, `Smart-Casting`이 적용돼 반환타입을 생략할 수 있다.

```kotlin
fun getA() = 1 // - 반환 챕터의 예시 함수와 같은 동작을 하는 함수
```



#### - 사용 예시

```kotlin
fun plus(one: Int, two: Int) = one + two // plus(1, 1) -> 2

fun divideWithOne(value: Int, one: Int = 1) = value / one // always `value`
```



## Null-Safety 속성

#### - Nul-Safety?

`null`인 요소에 특정 값을 가져오는 행동 같은 명령을 실행하면, 없는 값으로부터 요청했기에 오류가 발생한다.

이러한 상황을 효율적으로 제어할 수 있게 도와주는 속성이 `Null-Safety`인데 코틀린은 이 속성이 적용되었다.



#### - !!

`!!` 키워드는 값이 무조건 `null`이 아님을 약속한다.



사용법: [변수명]!!

> var a  = 1
>
> a!! // a는 null이 절대 아님을 보장

!!는 무조건 이게  `null`이 아님을 보장할 수 있는 순간 아니면 최대한 사용을 하지 않는게 좋다.

그래서 코틀린 개발자가 `!!`라는 못생긴 기호를 채택했다. 



#### - ?:

`?!` 키워드는 앞 조건이 `null`일 때 뒤 조건을 실행시키며, `엘비스 연산자`라고 불린다.

```kotlin
var a = null
var b = 1
var c = a ?: b // c에는 1이 들어감
```

`a ?: b` 에서 앞 조건인 `a`가 `null`이므로, 뒤 조건인 `b`의 값인 1이 `c` 변수에 들어간다.



#### - ?.

`?.` 키워드는 앞 조건이 `null`이 아닐때만 뒤 조건을 실행시키고, 만약 앞 조건이 `null`이라면 `null` 을 리턴한다.

```kotlin
var people = People()
var name = people?.name // people의 이름이 들어감
```

`people?.name`에서 앞 조건인 `people`이 `null`이 아닌 `People`이라는 값으로 초기화 됬으므로,

뒤 조건인 `name` 이 실행된다.



`?.` 키워드는 `엘비스 연산자`와 함께 쓰인다.

```kotlin
var people = null
var name = people?.name ?: "people 값이 없습니다" // `people 값이 없습니다`가 들어감
```

`people?.name ?: "people 값이 없습니다"`를 보면 `people`의 선언을 `null`로 해줬으므로,

앞 조건에 `null`이 들어와 뒤 조건인 `"people 값이 없습니다"`가 실행된다.



-----



# 2. 안드로이드 기초 지식

## 1. 기본 용어

- 엑티비티: 앱을 실행했을때 우리 눈에 보이는 화면
- 패키지명: 앱의 고유 아이디 같은 느낌, 플레이스토어에서 앱을 구분하는 기준이 됨
- 컴파일: 우리가 작성한 코드들을 기계어로 번역해주는 과정 (`Make Project`버튼으로 가능)
- SDK: API 레벨 이라고도 불리며, 앱 개발에 필요한 최소한의 안드로이드 버전을 뜻함
- 그레이들: 소스코드와 의존성 모듈들을 엮어서 컴파일하여 패키징하는 도구



## 2. 구성 요소

<img src="https://github.com/jisungbin/learn-kotlin-with-android/blob/master/images/android-default-package.png?raw=true" alt="android-default-package.png" style="zoom:50%;" />



#### - manifest

매니페스트 파일에는 안드로이드 앱에 대한 정보들이 들어간다.

> 사용 권한, 엑티비티, 앱의 테마... 등등



#### - java

앱 패키지명에 따른 폴더가 생성되고, 마지막 폴더에 코드들을 작성한다.



#### - res

앱에 쓰일 리소스들이 들어가는 폴더.

> 리소스) 폰트 파일, 이미지 파일, 래이아웃 파일 등등...



- drawable 폴더와 mipmap 폴더

  두 폴더 모두 이미지를 담는 폴더인데, 차이점이 존재한다.

  | **구분**        | **`drawable`**                      | **`mipmap`**                  |
  | --------------- | ----------------------------------- | ----------------------------- |
  | **목적**        | **모든 이미지** 저장                | **아이콘 이미지** 저장        |
  | **지원 버전**   | 모든 버전                           | API 2.3 (`Honeycomb`) 이상    |
  | **이미지 크기** | **디바이스 픽셀밀도에 따라 달라짐** | **이미지 크기에 따라 달라짐** |

  이미지를 확대하여 보여주는 기능을 구현할 때 이미지 파일을 `drawable`에 넣으면 이미지 자체가 확대되서 이미지가 손상되지만, 이미지 파일을 `mipmap`에 넣어주게 되면 **확대됐을때 적당한 크기를 가지는 이미지 파일을 보여준다.**



- values 폴더
  - colors.xml: 안드로이드에서 색상을 사용하려면 헥사 코드를 이용해야 하는데, 각각 색깔들의 헥사 코드에 이름을 붙여서 이름으로 접근할 수 있게 도와준다.
  - strings.xml: 앱에서 쓰이는 텍스트들을 모아둔 파일. 앱에서 오타가 발생했을때 찾아서 수정하기 쉽고, 다국어를 지원할때도 strings.xml 파일만 각각 언어들에 맞게 여러개 만들어주면 되는 편의성이 있어서 사용한다.
  - themes.xml: 앱의 색상등 앱의 전반적인 테마가 설정되는 파일이다.



#### - gradle scripts

모듈의 빌드 방법이 정의된 gradle 파일들이 위치해 있다.

빌드에 사용할 SDK 버전부터 어플리케이션 버전, 사용할 라이브러리 등 다양한 항목을 설정할 수 있다.



- `Project` 단위 gradle

  전체 프로젝트에 영향을 미침

  

- `Module` 단위 gradle

  해당 모듈에만 영향을 미침

